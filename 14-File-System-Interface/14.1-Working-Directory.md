# 14.1 Working Directory 工作目录

> Each process has associated with it a directory, called its current working directory or simply working directory, that is used in the resolution of relative file names (see Section 11.2.2 [File Name Resolution], page 264).

每个进程都一个与之相关联的目录，叫做当前工作目录或者简称为工作目录，用于解析相对文件名（见第264页第11.2.2节[文件名解析]）

> When you log in and begin a new session, your working directory is initially set to the home directory associated with your login account in the system user database. You can find any user’s home directory using the getpwuid or getpwnam functions; see Section 30.13 [User Database], page 865.

当你登录并开启一个新的会话时，你的工作目录会被初始化设置成系统用户数据库中与登录用户关联的家目录。你可以通过`getpwuid`或者`getpwnam`函数来找到任意一个用户的家目录；请参阅第30.13节[用户数据库]，第865页。

> Users can change the working directory using shell commands like cd. The functions described in this section are the primitives used by those commands and by other programs for examining and changing the working directory. Prototypes for these functions are declared in the header file unistd.h.

用户可以通过shell命令，如`cd`来切换工作目录。本节中描述的函数是使用这些命令和其他程序用于检查和更改工作目录的原语。这些函数的声明在头文件`unistd.h`中。

> char * getcwd (char *buffer, size t size) [Function]

**char * getcwd (char *buffer, size t size) [Function]**

> Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem fd | See Section 1.2.2.1 [POSIX Safety Concepts], page 2.

[-不知道怎么翻译-]

> The getcwd function returns an absolute file name representing the current working directory, storing it in the character array buffer that you provide. The size argument is how you tell the system the allocation size of buffer.

函数`getcwd`返回一个表示当前工作目录的绝对文件名，并将其存储在一个您提供的字符数组缓冲区中。size参数告诉徐通分配的缓冲区大小。

> The GNU C Library version of this function also permits you to specify a null pointer for the buffer argument. Then getcwd allocates a buffer automatically, as with malloc (see Section 3.2.3 [Unconstrained Allocation], page 45). If the size is greater than zero, then the buffer is that large; otherwise, the buffer is as large as necessary to hold the result.

这个函数的GNUC库版本还允许你对于buffer参数指定一个空指针，然后`getcwd`自动通过分配一个buffer，就像malloc一样（参见第45页第3.2.3节[无约束分配]）如果`size`大于0，那么缓冲区就那么大，否则，缓冲区就与保存结果所需要的大小一样大。

> The return value is buffer on success and a null pointer on failure. The following errno error conditions are defined for this function:

返回值在成功的情况下，是buffer指针，失败的情况下是一个空指针。下面是这个函数所定义的错误情况下的错误码`errno`

> EINVAL The size argument is zero and buffer is not a null pointer.
> ERANGE The size argument is less than the length of the working directory name. You need to allocate a bigger array and try again.
> EACCES Permission to read or search a component of the file name was denied.

EINVAL: size参数是0并且buffer不是一个空指针
ERANGE: size参数小于工作路径名的长度，你需要分配一个大一些的数组，并重新尝试
EACCES: 没有读取或者搜索文件名某个组件的权限

> You could implement the behavior of GNU’s getcwd (NULL, 0) using only the standard behavior of getcwd:

你可以仅使用getcwd的标准行为来实现GNU的getcwd(NULL, 0):

```c
gnu_getcwd ()
{
	size_t size = 100;
	while (1)
	{
		char *buffer = (char *) xmalloc (size);
		if (getcwd (buffer, size) == buffer)
			return buffer;
		free (buffer);
		if (errno != ERANGE)
			return 0;
	size *= 2;
	}
}
```

> See Section 3.2.3.2 [Examples of malloc], page 46, for information about xmalloc, which is not a library function but is a customary name used in most GNU software.

请参阅第46页第3.2.3.2节[malloc示例]，了解有关xmalloc的信息，xmalloc不是库函数，但是是多数GNU软件中使用的。

> char * getwd (char *buffer) [Deprecated Function]

**char * getwd (char *buffer) [不推荐的函数]**